
\section{Modelo de Dinâmica}
\label{sec:dinamica}

\subsection{Visão Geral}
O Modelo de Dinâmica é o responsável por fazer a predição no filtro de Kalman. Nosso Modelo de Dinâmica utiliza os dados do odômetro para conseguir realizar tal predição. Realizar a predição significa obter uma nova postura (i.e., coordenadas (x,y) e ângulo $\theta$ )  com os dados do odômetro e da última estimativa.

\subsection{Modelagem}

A plataforma-robô Pionner P2DX foi modelada de acordo com a figura~\ref{figura:modelorobo} abaixo.

\begin{figure}[h]%
\begin{center}
\includegraphics[width=.5\columnwidth]{imagens/modelorobo.jpg}
\caption{Arquitetura do Sistema completo.}%
\label{figura:modelorobo}%
\end{center}
\end{figure}

As equações para se obter a postura estimada do robô, a partir da última estimativa estão descritas abaixo:

\begin{gather}
	x(n)=x(n-1)+dt_{m}(n)cos(\theta(n))\\
	y(n)=y(n-1)+dt_{m}(n)sen(\theta(n))\\
	\theta(n)=\theta(n-1)+\delta\theta(n)
\end{gather}

Essas equações formam a chamada matriz f do Filtro de Kalman, responsável diretamente pela etapa de predição.

Além disso, por exigência do filtro de Kalman Extendido, é necessário calcular a matriz de covariâncias Q e a matriz F, de propagação das incertezas pelas derivadas da matriz f. 

\subsection{Incertezas e Covariâncias}

A propagação de incertezas, representada pela matriz F, é calculada através da matriz das derivadas da matriz f (conhecida por jacobiano de f). Pela simplicidade de f, a matriz F é facilmente deduzida para:


\[ F(n) = \left( \begin{array}{ccc}
1 & 0 & -\delta_{m}(n)sin(\Theta_{m}(n-1)) \\
0 & 1 & \delta_{m}(n)cos(\Theta_{m}(n-1)) \\
0 & 0 & 1 \end{array} \right).\] 
  
 
A matriz Q, da variância do Modelo de Dinâmica, por sua vez, dependerá das influências que o deslocamento linear causa sobre as estimativas linear e angular e da influência que o deslocamento angular causa também sobre as estimativas linear e angular. A soma quadrática desses componentes geram, respectivamente, a incerteza quadrática linear e angular.


\[ Q(n) = \left( \begin{array}{ccc}
\sigma^{2}_{d_{m}} cos^2(\Theta_{m}(n-1))  & \sigma^{2}_{d_{m}} cos(\Theta_{m}(n-1)) sin(\Theta_{m}(n-1)) & 0 \\
\sigma^{2}_{d_{m}} cos(\Theta_{m}(n-1)) sin(\Theta_{m}(n-1)) & \sigma^{2}_{d_{m}} sin^2(\Theta_{m}(n-1)) & 0 \\
0 & 0 & \sigma^{2}_{\theta_{m}} \end{array} \right).\]   


\subsection{Exemplo de Implementação}

Abaixo a classe mais genérica do Modelo de Dinâmica em C++, com os métodos para se obter a postura.

\begin{lstlisting}[language=C++]
		
pose_t ModeloDinamica::calculaX()
{
	
	return posicaoEstimada.X() 
	+ medidaOdometro.getDeltaDistance()*::cos(posicaoEstimada.Theta());
}


pose_t ModeloDinamica::calculaY()
{
	return posicaoEstimada.Y() 
	+ medidaOdometro.getDeltaDistance()*::sin(posicaoEstimada.Theta());
}


pose_t ModeloDinamica::calculaTheta()
{
    if(!floating_point::isEqual(medidaOdometro.getDeltaTheta(), 0))
    {
	    DINAMICA_LOG(logDEBUG2) 
	    << "Ultimo Theta Estimado: " << posicaoEstimada.Theta() 
	    << ". Delta Theta: " << medidaOdometro.getDeltaTheta();
    }
    return sauron::trigonometry::normalizeAngle(
    (posicaoEstimada.Theta() + medidaOdometro.getDeltaTheta()));
}
\end{lstlisting}



