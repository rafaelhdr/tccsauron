\subsection{Localização}\label{subsec:arqloc}.

A localização é o módulo mais complexo dentro da arquitetura deste trabalho. Ela foi projetada com base no filtro bayesiano EKF (\textit{Extended Kalman Filter}), melhor descrito no Apêndice \ref{sec:apendicea}.
\todo{Consertar a referência do apêndice}
Nesta seção, encontra-se a visão geral deste módulo e sua implementação. 

\subsubsection{Visão Geral}

O sistema de localização estima a posição do robô a partir dos dados de seus sensores. O odômetro, sensor interno, é utilizado como uma medida da execução dos comandos de navegação do sistema, estando relacionado com um Modelo da Dinâmica do Sistema. Os sensores externos têm associado a si um modelo de observação, que descreve a relação da medida lida com o mundo real. Por exemplo, o modelo de observação do sonar associa uma leitura a uma parede no mapa. 

O modelo de observação de cada sensor externo sabe qual é a observação esperada para uma dada postura do robô, uma vez que ele conhece o mapa do robô. Uma diferença entre a observação esperada e a observação de fato recebida indica um erro na estimativa do sistema. Se esses erros forem pequenos, podem ser consequência das variações naturais dos sensores físicos. Contudo, diferenças grandes devem ser utilizadas para corrigir a postura. O ponto mais importante do algoritmo de localização é exatamente este: a partir da diferença entre as observações esperadas e reais, atualizar a estimativa da postura.

Essas estimativas, corrigidas pelos modelos de observação dos sensores externos, são previstas pelo modelo de dinâmica. Seu papel é gerar uma predição a partir da última postura estimada do robô, sabendo o quanto ele andou nesse intervalo. Existem duas abordagens a esse problema. A primeira é utilizar os sinais de controle, como velocidade de cada roda, para prever o movimento do robô. A segunda, utilizada neste trabalho, é obter as informações a partir do odômetro do robô.

O filtro de Kalman estendido (EKF) é um filtro matemático capaz de realizar a previsão e correção das estimativas de postura. Por fim, o último componente do sistema é o módulo de coordenação, que liga os demais componentes do sistema de localização, iniciando os sensores e associando-os ao EKF.


A dinâmica de funcionamento do módulo de localização usando o EKF está ilustrada na figura \ref{fig:dinamicaekf}, onde inicialmente tem-se uma postura estimada $\hat{\textbf{x}_{t-1}}$ que é utilizada pelo Modelo de Dinâmica, junto da leitura do odômetro, na predição de uma nova postura $\bar{\textbf{x}_{t}}$. O sistema então utiliza as medidas da visão e dos sonares para efetuar uma correção na predição $\bar{\textbf{x}_{t}}$, estimando a nova postura do robô, $\hat{\textbf{x}_{t}}$, que é a saída do sistema. O processo se repete enquanto for necessário.


\begin{figure}[ht]
	\centering
		\includegraphics[width=.8\columnwidth]{imagens/dinamicaModuloLocalizacaoEkf.jpg}
	\caption{Dinâmica do módulo de localização, usando EKF.}
	\label{fig:dinamicaekf}
\end{figure}


A figura \ref{fig:arquiteturalocalizacao} ilustra a arquitetura do módulo de localização. As informações retornadas pelos modelos dos sensores são a observação real ($z$), observação esperada ($h$), matriz de observação -- que descreve como a observação depende dos componentes $x$, $y$ e $\theta$ da postura estimada -- ($H$) e a covariância ($R$).


\begin{figure}[ht]
	\centering
		\includegraphics[width=.8\columnwidth]{imagens/arquiteturaModuloLocalizacao.jpg}
	\caption{Arquitetura do módulo de localização}
	\label{fig:arquiteturalocalizacao}
\end{figure}

\subsubsection{Implementação}

Uma dificuldade em se implementar um sistema como o resumido acima é o controle do fluxo de execução. Para explicar o problema, pode-se observar o algoritmo \ref{algo:localizacao}, um esboço do funcionamento básico do módulo de localização.

\begin{algorithm}
\dontprintsemicolon
\caption{Esboço do algoritmo do módulo de localização}
\label{algo:localizacao}
\SetKw{recebe}{$\leftarrow$}
\SetKwBlock{RepitaSempre}{repita}{fim}
\SetKwData{ekf}{ekf}
\SetKwData{sensor}{sensor}
\SetKwData{dinamica}{dinâmica}
\SetKwData{modeloObservacao}{modeloObservacao}
\SetKw{Em}{em}
\SetKwData{postura}{postura}
\RepitaSempre{
	\postura \recebe \ekf.previsao(\dinamica.novaEstimativa()) \;
	\ParaCada{\modeloObservacao}{
		\Se{ \sensor.temMedidaNova()}{
			\postura \recebe \ekf.update(\modeloObservacao.observacaoEsperada()) \;
		}
	}
	}\end{algorithm}

A implementação ingênua desse algoritmo percorre os passos do pseudocódigo sequencialmente, ou seja, percorre pelo modelo de dinâmica e por todos modelos de observação à procura daqueles que estejam prontos. A tabela \ref{tab:frequenciaSensores} mostra que os diferentes tempos de atualização de cada modelo tornam essa abordagem inviável: na grande maioria das vezes, não haverá nenhum modelo de observação pronto, e a única estimativa será aquela fornecida pelo modelo de dinâmica. Além disso, o laço de processamento é executado o tempo todo, consumindo CPU e aumentando ainda mais o tempo de resposta dos modelos de observação.

\begin{table}[htbp]
	\centering
		\begin{tabular}{ | l | r | }
		\hline
		Modelo & Tempo de atualização (ms) \\ \hline
		Dinâmica (Odômetro) & 5 \\ \hline
		Observação (Visão) & 25 \\ \hline
		Observação (Sonar) & 100 \\ \hline			
		\end{tabular}
	\caption{Frequência de atualização dos modelos de dinâmica e observação}
	\label{tab:frequenciaSensores}
\end{table}

A solução é transferir o controle do fluxo de execução de um módulo central para os modelos. Quando um sensor receber novas medidas e for capaz de gerar uma observação esperada, ele chama o Gerenciador de Localização, que então invoca o EKF e computa a nova estimativa. Esse processo é muito mais eficiente do que o \textit{polling}, pois não há recursos desperdiçados enquanto se espera inutilmente. A desvantagem do método distribuído é que um certo tempo deve ser perdido realizando a sincronização de todas as \textit{threads} (para evitar, por exemplo, que dois sensores atualizem a estimativa ao mesmo tempo, corrompendo-a). A tabela \ref{tab:usoProcessador} relata os resultados obtidos, em termos do uso médio dos processadores, para cada abordagem, centraliada e distribuída.

\begin{table}[htbp]
	\centering
		\begin{tabular}{ | l | r | }
		\hline
		Abordagem & Utilização média dos processadores \\ \hline
		Centralizada & 50\% \\ \hline
		Distribuída & 11\% \\ \hline
		\end{tabular}
	\caption{Uso do processador nas duas abordagens de implementação (sistema com duas CPUs)}
	\label{tab:usoProcessador}
\end{table}

\input{modelodinamica}
\input{nossosonar}
\input{modeloVisao}