package br.com.r4j.research.image.sequence.featurematch.vline.test;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.IOException;
import java.io.File;
import java.awt.*;
import java.util.*;
import java.awt.image.*;

import javax.media.*;
import javax.media.format.*;
import javax.media.protocol.*;
import javax.media.util.*;
import javax.media.control.*;

import br.com.r4j.image.*;
import br.com.r4j.commons.util.*;
import br.com.r4j.math.*;
import br.com.r4j.research.image.sequence.featurematch.vline.*;

import br.com.r4j.research.*;
import br.com.r4j.research.vline.*;

import br.com.r4j.configurator.*;

import br.com.r4j.video.operation.threebandpacked.*;
import br.com.r4j.studio.*;
import br.com.r4j.research.image.sequence.*;
import br.com.r4j.research.pose2destimation.*;

import JSci.maths.*;



public class VideoFileAcquisitor implements Runnable, ControllerListener
{
	private static Log log = LogFactory.getLog(VideoFileAcquisitor.class.getName());

	private Pose2DGrabber poseGrabber = null;

	private String strDir2Save = null;
	private File flDir2Save = null;
	private String strVideoFile = null;

	private FileDataSourceManager camSource = null;
	private ProcessorManager procMan = null;
	private FrameGrab2DirEffect copy2dirEffect = null;	
	private boolean bIsDSConnected = false;
	private boolean bIsProcessorCreated = false;
	private boolean bIsGraphConnected = false;


	private boolean bRunning = false;



	public VideoFileAcquisitor()
	{
	}

	
	public void setPoseGrabber(Pose2DGrabber poseGrbr)	{this.poseGrabber = poseGrbr;}
	public void setDir2Save(String strDir2Save)	
	{
		this.strDir2Save = strDir2Save;
		this.flDir2Save = new File(strDir2Save);
		if (!this.flDir2Save.exists())
			this.flDir2Save.mkdirs();
	}

	public void setVideoFile(String strVideoFile)	{this.strVideoFile = strVideoFile;}


	public boolean initEngine()
	{
		try
		{
			camSource = new FileDataSourceManager();
			log.debug("strVideoFile = " + strVideoFile);
			camSource.setFilename(strVideoFile);
			camSource.open();

			procMan = new EffectProcessorManager();

			copy2dirEffect = new FrameGrab2DirEffect();
			copy2dirEffect.setThumbnailDir(flDir2Save);
			copy2dirEffect.setPoseGrabber(poseGrabber);

			return true;
		}
		catch (Exception e)
		{
			e.printStackTrace();
			log.debug(e);

			return false;
		}
	}


	public void runEngine()
	{
		bRunning = true;
		Thread thr = new Thread(this);
		thr.start();
	}

	
	public void run()
	{
		log.debug("run:begin");

		Processor proc = null;
		try
		{
			camSource.open();
			bIsDSConnected = true;
			camSource.start();
			DataSource dSourceOri = camSource.getDataSource();

			procMan.setContentDescriptor(null);
			procMan.setFilters(br.com.r4j.commons.util.Collections.createList(copy2dirEffect));
			procMan.setDataSource(dSourceOri);
			proc = procMan.getProcessor();

			if (proc == null)
			{
				log.error("Não foi possível iniciar o processador: erro interno");
				this.resetAll();
				return;
			}

			proc.addControllerListener(this);
			procMan.open();
			procMan.start();
			if (camSource instanceof ComplexDataSourceManager)
				((ComplexDataSourceManager) camSource).afterStartPorcessorStart();
			bIsProcessorCreated = true;
		}
		catch (Exception e)
		{
			log.error("startGraph:error", e);
			this.resetAll();
			return;
		}
		bIsGraphConnected = true;
	}


	public void resetAll()
	{
		if (bIsProcessorCreated)
		{
			log.debug("stopGraph:begin");
			try
			{
				if (procMan != null)
				{
					procMan.stop();
					procMan.getProcessor().removeControllerListener(this);
					procMan.close();
				}
				camSource.stop();
			}
			catch (Exception e)
			{
				e.printStackTrace();
				log.error("stopGraph:error", e);
			}
		}
		bIsGraphConnected = false;
		bIsProcessorCreated = false;
		log.debug("stopGraph:end");
	}


	public void stopEngine()
	{
		bRunning = false;
		this.resetAll();
	}


	///////////////////////////////////
	//////// ControllerListener ///////
	///////////////////////////////////

    public synchronized void controllerUpdate(ControllerEvent event)
	{
		log.debug("controllerUpdate:event = " + event);
        Processor proc = null;
        Controller controller = (Controller) event.getSource();
		System.err.println("controllerUpdate:controller = " + controller);
		log.debug("controllerUpdate:controller = " + controller);
		if (controller != null)
			log.debug("controllerUpdate:controller.getClass().getName() = " + controller.getClass().getName());
        if (controller instanceof Processor)
            proc = (Processor) controller;

        if (event instanceof StopByRequestEvent)
		{
			log.debug("controllerUpdate:event instanceof StopByRequestEvent");
			// Não pode pois pause cai aqui ...
////			ui.setVisualAndControlComponent(null, null);
        }		
    }
}
