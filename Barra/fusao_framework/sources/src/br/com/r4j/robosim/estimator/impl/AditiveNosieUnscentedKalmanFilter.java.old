package br.com.r4j.robosim.estimator.impl;

import java.util.ArrayList;
import java.util.Iterator;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import JSci.maths.AbstractDoubleMatrix;
import JSci.maths.AbstractDoubleSquareMatrix;
import JSci.maths.AbstractDoubleVector;
import JSci.maths.DoubleMatrix;
import JSci.maths.DoubleSquareMatrix;
import JSci.maths.DoubleVector;
import br.com.r4j.commons.util.MatrixUtil;
import br.com.r4j.configurator.ConfiguratorException;
import br.com.r4j.math.JSciMatrixMath;
import br.com.r4j.robosim.estimator.DynamicModel;
import br.com.r4j.robosim.estimator.EKFDoubleVectorFunction;
import br.com.r4j.robosim.estimator.EstimationException;
import br.com.r4j.robosim.estimator.Estimator;
import br.com.r4j.robosim.estimator.ModelFilter;
import br.com.r4j.robosim.estimator.Sensor;
import br.com.r4j.robosim.estimator.SensorModel;
import br.com.r4j.robosim.estimator.UKFDoubleVectorFunction;


public class AditiveNosieUnscentedKalmanFilter extends BaseEstimator
{
	private static Log log = LogFactory.getLog(AditiveNosieUnscentedKalmanFilter.class.getName());
	private static Log logUKF = LogFactory.getLog("ukf");
	private static Log logUKF_I = LogFactory.getLog("ukf_input");
	private static Log logUKF_covar = LogFactory.getLog("ukf_covar");
	private static Log logTime = LogFactory.getLog("time");

	
	private UKFDoubleVectorFunction stateFunction = null;


	public AditiveNosieUnscentedKalmanFilter()
	{
		super();
	}


	public String getName()
	{
		return "Filtro de Kalman Unscented";
	}


	public void addSensorModel(SensorModel sensModel, Sensor sens) throws ConfiguratorException
	{
		if (!(sensModel instanceof UKFDoubleVectorFunction))
			throw new ConfiguratorException("Sensor Model " + sensModel.getName() + " não implementa EKFDoubleVectorFunction");

		super.addSensorModel(sensModel, sens);
	}


	public void setDynamicModel(DynamicModel dynModel, Sensor dynModelSensor) throws ConfiguratorException
	{
		if (!(dynModel instanceof UKFDoubleVectorFunction))
			throw new ConfiguratorException("Dynamic Model " + dynModel.getName() + " não implementa EKFDoubleVectorFunction");

		stateFunction = (UKFDoubleVectorFunction) dynModel;

		super.setDynamicModel(dynModel, dynModelSensor);
	}

	
	protected void doEstimate()
	{
		logUKF.debug("------------------------------ NOVA ITER");
		logUKF.debug("stateEstimate: \r\n" + MatrixUtil.toString(stateEstimate, 9, 7));
		logUKF.debug("stateCovarEstimate: \r\n" + MatrixUtil.toString(stateCovarEstimate, 9, 10));

		// predição
		AbstractDoubleVector vectDynReadings = new DoubleVector(dynModelSensor.getDataDimension());
		dynModelSensor.getData(vectDynReadings);
		AbstractDoubleSquareMatrix snsQ = dynModelSensor.getDataCovariance();
		logUKF.debug("snsQ: \r\n" + MatrixUtil.toString(snsQ, 9, 7));
		AbstractDoubleSquareMatrix Q = dynModel.getModelIncrementalCovariance(stateEstimate, vectDynReadings, dynModelSensor.getDataCovariance());
		logUKF.debug("vectDynReadings: \r\n" + MatrixUtil.toString(vectDynReadings, 9, 7));
		logUKF.debug("Q: \r\n" + MatrixUtil.toString(Q, 9, 7));

		int totalSize = stateEstimate.dimension();

		// Calcula os sigmas iniciais
		double detQ = 1; for (int idxVar = 0; idxVar < Q.rows(); idxVar++)
			detQ *= Q.getElement(idxVar, idxVar);
		logUKF.debug("detQ: " + detQ);
		logUKF.debug("Q.det(): " + Q.det());
		
		// Indica que pode ser usado a matriz Q para aumentar o estado.
		if (detQ > 0)
			totalSize += Q.rows(); 

		// Verifica quais sensores possuem observacões.
		ArrayList listObsObjects = new ArrayList();  
		ArrayList listObsSigmaPoints = new ArrayList();  
		Iterator itSensModels = listSensModels.iterator();
		Iterator itSens = listSens.iterator();
		while (itSensModels.hasNext())
		{
			SensorModel snsModel = (SensorModel) itSensModels.next();
			Sensor sns = (Sensor) itSens.next();
			UKFDoubleVectorFunction snsFunc = (UKFDoubleVectorFunction) snsModel;

			boolean bResults = sns.hasNewData();
			if (bResults)
			{
				AbstractDoubleVector vectReadings = new DoubleVector(sns.getDataDimension());
				sns.getData(vectReadings);
				AbstractDoubleSquareMatrix snsR = sns.getDataCovariance();
				bResults = snsModel.canProduceObservations(vectReadings, snsR);
				if (bResults)
				{
					AbstractDoubleVector vectObservations = snsModel.getObservation(vectReadings);
					AbstractDoubleSquareMatrix R = snsModel.getObservationCovariance(snsR);
					logUKF.debug("R: \r\n" + MatrixUtil.toString(R, 9, 4));
					
					listObsObjects.add(snsModel);
					listObsObjects.add(vectObservations);
					listObsObjects.add(R);
					
					totalSize += R.rows();
				}
			}
		}

		AbstractDoubleSquareMatrix stateCovarAugmented = new DoubleSquareMatrix(totalSize);
		AbstractDoubleVector stateAugmented = new DoubleVector(totalSize);
		int sizeCount = 0;
		MatrixUtil.copyBlock(sizeCount, stateCovarAugmented, stateCovarEstimate);
		MatrixUtil.copy(sizeCount, stateAugmented, stateEstimate);
		sizeCount += stateCovarEstimate.rows();
		if (detQ > 0)
		{
			MatrixUtil.copyBlock(sizeCount, stateCovarAugmented, Q);
			sizeCount += Q.rows();
		}
		for (int i = 0; i < listObsObjects.size(); i += 3)
		{
			AbstractDoubleSquareMatrix R = (AbstractDoubleSquareMatrix) listObsObjects.get(i + 2);  
			MatrixUtil.copyBlock(sizeCount, stateCovarAugmented, R);
			sizeCount += R.rows();
		}

		double delta = 3 - stateEstimate.dimension();
		double gamma = Math.sqrt(stateEstimate.dimension() + delta);
		double w0state = delta/(delta + stateEstimate.dimension());
		double w0cov = w0state;
		double wi = 1.0/(delta + stateEstimate.dimension())/2;
		logUKF.debug("w0state = " + w0state + ", w0cov = " + w0cov + ", wi = " + wi + ", gamma: " + gamma + ", delta = " + delta);

		AbstractDoubleMatrix stateLastSigma = this.generateSigmaPoints(stateEstimate, stateCovarEstimate, gamma);
		if (stateLastSigma != null)
			logUKF.debug("stateLastSigma: \r\n" + MatrixUtil.toString(stateLastSigma, 9, 7));
		else
		{
			logUKF.debug("stateLastSigma: null!");
			throw new EstimationException("UKF: stateLastSigma: null. Não pode estimar.");
		}
/*
		delta = 3 - stateAugmented.dimension();
		gamma = Math.sqrt(stateAugmented.dimension() + delta);
		w0state = delta/(delta + stateAugmented.dimension());
		w0cov = w0state;
		wi = 1.0/(delta + stateAugmented.dimension())/2;
		logUKF.debug("w0state = " + w0state + ", w0cov = " + w0cov + ", wi = " + wi + ", gamma: " + gamma + ", delta = " + delta);
//*/
		logUKF.debug("stateAugmented: \r\n" + MatrixUtil.toString(stateAugmented, 9, 7));
		logUKF.debug("stateCovarAugmented: \r\n" + MatrixUtil.toString(stateCovarAugmented, 9, 7));
		logUKF.debug("stateCovarAugmented: stateCovarAugmented.det()" + stateCovarAugmented.det());
//		AbstractDoubleMatrix stateLastSigmaAugmented = this.generateSigmaPoints(stateAugmented, stateCovarAugmented, gamma);
		stateLastSigma = this.generateSigmaPoints(stateEstimate, stateCovarEstimate, gamma);
//		logUKF.debug("stateLastSigmaAugmented: \r\n" + MatrixUtil.toString(stateLastSigmaAugmented, 9, 7));

//		stateLastSigma = MatrixUtil.getRows(stateLastSigmaAugmented, 0, stateCovarEstimate.rows());
		stateLastSigma = stateLastSigma;
		logUKF.debug("stateLastSigmaNew: \r\n" + MatrixUtil.toString(stateLastSigma, 9, 7));
		sizeCount = stateCovarEstimate.rows();

		AbstractDoubleMatrix stateErrorSigma = null;
		if (detQ > 0)
		{
			double deltaQ = 3 - Q.rows();
			double gammaQ = Math.sqrt(Q.rows() + deltaQ);
			stateErrorSigma = this.generateSigmaPoints(new DoubleVector(Q.rows()), Q, gammaQ);
//			stateLastSigma = MatrixUtil.getRows(stateLastSigmaAugmented, sizeCount, Q.rows());
			sizeCount = Q.rows();
		}
		else
			stateErrorSigma = new DoubleMatrix(Q.rows(), Q.rows()*2 + 1);
		logUKF.debug("stateErrorSigma: \r\n" + MatrixUtil.toString(stateErrorSigma, 9, 7));

		for (int i = 0; i < listObsObjects.size(); i += 3)
		{
			AbstractDoubleSquareMatrix R = (AbstractDoubleSquareMatrix) listObsObjects.get(i + 2);  
			double deltaR = 3 - R.rows();
			double gammaR = Math.sqrt(R.rows() + deltaR);
			listObsSigmaPoints.add(this.generateSigmaPoints(new DoubleVector(R.rows()), R, gammaR));
//			listObsSigmaPoints.add(MatrixUtil.getRows(stateLastSigmaAugmented, sizeCount, R.rows()));
			sizeCount += R.rows();
		}

		// Calcula os sigmas pela tranformação de estado
		AbstractDoubleMatrix sigmaStatei_iminus1 = new DoubleMatrix(stateLastSigma.rows(), stateLastSigma.columns());
		stateFunction.produceResults(stateLastSigma, vectDynReadings, stateErrorSigma, sigmaStatei_iminus1, this.getCovariance());
		logUKF.debug("sigmaStatei_iminus1: \r\n" + MatrixUtil.toString(sigmaStatei_iminus1, 9, 7));

		// 2 - Calcula os vetores ...
		AbstractDoubleVector statei_iminus1 = this.calculateMean(sigmaStatei_iminus1, w0state, wi);
		logUKF.debug("statei_iminus1: \r\n" + MatrixUtil.toString(statei_iminus1, 9, 7));
		AbstractDoubleSquareMatrix Pi_iminus1 = this.calculateCov(sigmaStatei_iminus1, statei_iminus1, w0cov, wi);
		Pi_iminus1 = Pi_iminus1.add(Q);
		logUKF.debug("Pi_iminus1: \r\n" + MatrixUtil.toString(Pi_iminus1, 9, 4));
		double det = Pi_iminus1.det();
		logUKF.debug("Pi_iminus1.isSymmetric(): " + Pi_iminus1.isSymmetric() + ", Pi_iminus1.det(): " + det);
		this.setPredictedState(statei_iminus1, Pi_iminus1);

		Iterator itObsObjects = listObsObjects.iterator();
		Iterator itObsSigmaPoints = listObsSigmaPoints.iterator();
		while (itObsObjects.hasNext())
		{
			SensorModel snsModel = (SensorModel) itObsObjects.next();
			UKFDoubleVectorFunction snsFunc = (UKFDoubleVectorFunction) snsModel;
			AbstractDoubleVector vectObservations = (AbstractDoubleVector) itObsObjects.next();
			AbstractDoubleSquareMatrix R = (AbstractDoubleSquareMatrix) itObsObjects.next();
			AbstractDoubleMatrix sigmaErrorObs = (AbstractDoubleMatrix) itObsSigmaPoints.next();
			logUKF.debug("sigmaErrorObs: \r\n" + MatrixUtil.toString(sigmaErrorObs, 9, 7));
			
			// Calcula os sigmas pela tranformação de medição
			DoubleMatrix obsPredSigma = new DoubleMatrix(sigmaErrorObs.rows(), sigmaStatei_iminus1.columns());
			snsFunc.produceResults(sigmaStatei_iminus1, statei_iminus1, new DoubleMatrix(sigmaErrorObs.rows(), sigmaStatei_iminus1.columns()), obsPredSigma, Pi_iminus1);
			logUKF.debug("obsPredSigma: \r\n" + MatrixUtil.toString(obsPredSigma, 9, 7));

			AbstractDoubleVector obsPred = this.calculateMean(obsPredSigma, w0state, wi);

			AbstractDoubleSquareMatrix pYY = this.calculateCov(obsPredSigma, obsPred, w0cov, wi);
			logUKF.debug("pYY: \r\n" + MatrixUtil.toString(pYY, 9, 4));
			pYY = pYY.add(R);

			AbstractDoubleMatrix pXY = this.calculateCov(sigmaStatei_iminus1, statei_iminus1, obsPredSigma, obsPred, w0cov, wi);
			logUKF.debug("pXY: \r\n" + MatrixUtil.toString(pXY, 9, 4));

			AbstractDoubleSquareMatrix pYYInv = pYY.inverse();
			AbstractDoubleMatrix gain = pXY.multiply(pYYInv);
			logUKF.debug("gain: \r\n" + MatrixUtil.toString(gain, 9, 4));

			AbstractDoubleVector obsDiff = vectObservations.subtract(obsPred);
			AbstractDoubleVector stateGain =  gain.multiply(obsDiff);
			AbstractDoubleVector statei_i = statei_iminus1.add(stateGain);

			AbstractDoubleMatrix gain_x_pYY_x_gainT = gain.multiply(pYY).multiply((AbstractDoubleMatrix) gain.transpose());
			AbstractDoubleSquareMatrix pXXcorrSim = MatrixUtil.convert2SquareMatrix(gain_x_pYY_x_gainT);
			logUKF.debug("pXXcorrSim: \r\n" + MatrixUtil.toString(pXXcorrSim, 9, 7));

			AbstractDoubleSquareMatrix Pi_i = MatrixUtil.convert2SquareMatrix(Pi_iminus1.subtract(pXXcorrSim));

			this.setState(statei_i, Pi_i);
			statei_iminus1 = statei_i; Pi_iminus1 = Pi_i;
		}
	}


	protected AbstractDoubleMatrix generateSigmaPoints(AbstractDoubleVector mean, AbstractDoubleSquareMatrix covar, double gamma)
	{
		DoubleMatrix sigma = new DoubleMatrix(mean.dimension(), mean.dimension()*2 + 1);

		AbstractDoubleSquareMatrix [] arraySqrts = null;
		double det = covar.det();
		double m = 1, m2 = 1;
		logUKF.debug("generateSigmaPoints:det = " + det);
		if (Double.isNaN(det))
		{
			double multDet = 1;
			for (int idxVar = 0; idxVar < covar.rows(); idxVar++)
				multDet *= covar.getElement(idxVar, idxVar);

			logUKF.debug("if (Double.isNaN(det)): multDet = " + multDet);
			if (multDet > 0 && multDet < 5.0E-7)
			{
				m2 = 5.0E-7/(covar.rows()*multDet);
				m = Math.sqrt(m2);
				covar = MatrixUtil.convert2SquareMatrix(covar.scalarMultiply(m2));
				logUKF.debug("buster(m2): " + m2);
				arraySqrts = JSciMatrixMath.choleskyDecompose(covar);
			}
			else if (multDet > 0)
			{
				arraySqrts = JSciMatrixMath.choleskyDecompose(covar);
			}
			else if (multDet == 0)
			{
				arraySqrts = new AbstractDoubleSquareMatrix[1];
				arraySqrts[0] = new DoubleSquareMatrix(covar.rows());
			}
			else // if (Double.isNaN(det))
			{
				return null;
			}
		}
		else if (det > 0)
		{
			logUKF.debug("else if (det > 0)");
			arraySqrts = JSciMatrixMath.choleskyDecompose(covar);
		}
		else if (det == 0)
		{
			logUKF.debug("else if (det == 0)");
			arraySqrts = new AbstractDoubleSquareMatrix[1];
			arraySqrts[0] = new DoubleSquareMatrix(covar.rows());
		}
		else
		{
			logUKF.error("else if (det <<< 0)!!");
			return null;
		}
		logUKF.debug("arraySqrts[0]: \r\n" + MatrixUtil.toString(arraySqrts[0], 9, 7));
		logUKF.debug("covar busted: \r\n" + MatrixUtil.toString(covar, 9, 4));
		
		arraySqrts[0] = MatrixUtil.convert2SquareMatrix(arraySqrts[0].scalarDivide(m));
		logUKF.debug("arraySqrts[0]: \r\n" + MatrixUtil.toString(arraySqrts[0], 9, 7));

		
		for (int idxVar = 0; idxVar < mean.dimension(); idxVar++)
			sigma.setElement(idxVar, 0, mean.getComponent(idxVar));
		for (int idxVar = 0; idxVar < mean.dimension(); idxVar++)
		{
			for (int idxObj = 0; idxObj < mean.dimension(); idxObj++)
			{
				// Invertido para pegar o valor das linhas da raiz para as colunas dos sigmas.
////				double val = gamma*arraySqrts[0].getElement(idxObj, idxVar);
				double val = gamma*arraySqrts[0].getElement(idxVar, idxObj);
				sigma.setElement(idxVar, idxObj + 1, mean.getComponent(idxVar) + val);
				sigma.setElement(idxVar, idxObj + 1 + mean.dimension(), mean.getComponent(idxVar) - val);
			}
		}

		return sigma;
	}


	public AbstractDoubleVector calculateMean(AbstractDoubleMatrix sigma, double w0state, double wi)
	{
		DoubleVector mean = new DoubleVector(sigma.rows());
		for (int idxState = 0; idxState < sigma.rows(); idxState++)
		{
			double val = w0state*sigma.getElement(idxState, 0);
			for (int i = 1; i < sigma.columns(); i++)
				val += wi*sigma.getElement(idxState, i);
			mean.setComponent(idxState, val);
		}
		return mean;
	}


	public AbstractDoubleSquareMatrix calculateCov(AbstractDoubleMatrix sigma, AbstractDoubleVector mean, double w0cov, double wi)
	{
		AbstractDoubleSquareMatrix cov = new 	DoubleSquareMatrix(mean.dimension());

		AbstractDoubleSquareMatrix matrixTemp = new DoubleSquareMatrix(mean.dimension());
		for (int i = 0; i < mean.dimension(); i++) for (int j = 0; j <= i; j++)
		{
			double val = w0cov*(sigma.getElement(i, 0) - mean.getComponent(i))*
							   (sigma.getElement(j, 0) - mean.getComponent(j));
			matrixTemp.setElement(i, j, val);
			matrixTemp.setElement(j, i, val);
		}
		cov = cov.add(matrixTemp);
		for (int idxObjs = 0; idxObjs < mean.dimension(); idxObjs++)
		{
			for (int i = 0; i < mean.dimension(); i++) for (int j = 0; j <= i; j++)
			{
				double val = wi*(sigma.getElement(i, idxObjs + 1) - mean.getComponent(i))*
								(sigma.getElement(j, idxObjs + 1) - mean.getComponent(j)) +
							 wi*(sigma.getElement(i, idxObjs + sigma.columns()/2 + 1) - mean.getComponent(i))*
								(sigma.getElement(j, idxObjs + sigma.columns()/2 + 1) - mean.getComponent(j));
				matrixTemp.setElement(i, j, val);
				matrixTemp.setElement(j, i, val);
			}
			cov = cov.add(matrixTemp);
		}
		return cov;
	}


	public AbstractDoubleMatrix calculateCov(AbstractDoubleMatrix sigma_1, AbstractDoubleVector mean_1, AbstractDoubleMatrix sigma_2, AbstractDoubleVector mean_2, double w0cov, double wi)
	{
		AbstractDoubleMatrix cov = new DoubleMatrix(mean_1.dimension(), mean_2.dimension());
			
		AbstractDoubleMatrix matrixTemp = new DoubleMatrix(mean_1.dimension(), mean_2.dimension());
		for (int i = 0; i < mean_1.dimension(); i++) for (int j = 0; j < mean_2.dimension(); j++)
		{
			double val = w0cov*(sigma_1.getElement(i, 0) - mean_1.getComponent(i))*
							   (sigma_2.getElement(j, 0) - mean_2.getComponent(j));
			matrixTemp.setElement(i, j, val);
		}
		cov = cov.add(matrixTemp);
		for (int idxObjs = 0; idxObjs < mean_1.dimension(); idxObjs++)
		{
			for (int i = 0; i < mean_1.dimension(); i++) for (int j = 0; j < mean_2.dimension(); j++)
			{
				double val = wi*(sigma_1.getElement(i, idxObjs + 1) - mean_1.getComponent(i))*
								(sigma_2.getElement(j, idxObjs + 1) - mean_2.getComponent(j)) + 
							 wi*(sigma_1.getElement(i, idxObjs + sigma_1.columns()/2 + 1) - mean_1.getComponent(i))*
								(sigma_2.getElement(j, idxObjs + sigma_2.columns()/2 + 1) - mean_2.getComponent(j));
				matrixTemp.setElement(i, j, val);
			}
			cov = cov.add(matrixTemp);
		}
		return cov;
	}


	public static ModelFilter getModelFilter()
	{
		return new UKFModelFilter();
	}
}


class UKFModelFilter implements ModelFilter
{
	public boolean canUseDynamicModel(DynamicModel dynModel)
	{
		return (dynModel instanceof UKFDoubleVectorFunction);
	}


	public boolean canUseSensorModel(SensorModel sensModel)
	{
		return (sensModel instanceof UKFDoubleVectorFunction);
	}
}

