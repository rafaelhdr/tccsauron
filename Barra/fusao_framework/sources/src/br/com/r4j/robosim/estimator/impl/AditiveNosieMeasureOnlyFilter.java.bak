package br.com.r4j.robosim.estimator.impl;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import br.com.r4j.commons.util.MatrixUtil;
import br.com.r4j.math.*;

import br.com.r4j.robosim.estimator.*;

import JSci.maths.*;


public class AditiveNosieMeasureOnlyFilter extends BaseEstimator implements Estimator
{
	private static Log log = LogFactory.getLog(AditiveNosieMeasureOnlyFilter.class.getName());
	
	private Sensor sens = null;
	private InvertibleEKFDoubleVectorFunction sensModel = null;


	public AditiveNosieMeasureOnlyFilter()
	{
		bAltered = true;
		listTrackers = new ArrayList();
	}


	public String getName()
	{
		return "Filtro de Kalman Extendido";
	}


	public void addSensorModel(SensorModel sensModel, Sensor sens) throws ConfiguratorException
	{
		if (!(sensModel instanceof InvertibleEKFDoubleVectorFunction))
			throw new ConfiguratorException("Sensor Model " + sensModel.getName() + " não implementa InvertibleEKFDoubleVectorFunction");

		this.sens = sens;
		this.sensModel = (InvertibleEKFDoubleVectorFunction) sensModel;

		super.addSensorModel(sensModel, sens);
	}

	
	public List getSensorModels()
	{
		return Collections.createList(sensModel);
	}

	
	public void estimate()
	{
		if (bAltered)
		{
			bAltered = false;
			this.prepareBuffers();
		}


		AbstractDoubleVector vectReadings = new DoubleVector(snsModelSensor.getDataDimension());
		snsModelSensor.getData(vectReadings);
		stateEstimate = snsModel.produceInverseResults(stateEstimate, vectReadings);

		AbstractDoubleMatrix invHi = sensModel.getInverseTransitionMatrixJacobian(vectReadings);
		AbstractDoubleMatrix R = snsModel.getObservationCovariance(snsModelSensor.getDataCovariance());
		AbstractDoubleMatrix reTmp = invHi.multiply(R.multiply((AbstractDoubleMatrix) invHi.transpose()));
		stateCovarEstimate = MatrixUtil.convert2SquareMatrix(reTmp);

		this.fireNewRobotPose();
	}


	public static ModelFilter getModelFilter()
	{
		return new InvertibleEKFModelFilter();
	}
}


class InvertibleEKFModelFilter implements ModelFilter
{
	public boolean canUseDynamicModel(DynamicModel dynModel)
	{
		return (dynModel instanceof InvertibleEKFDoubleVectorFunction);
	}


	public boolean canUseSensorModel(SensorModel sensModel)
	{
		return (sensModel instanceof InvertibleEKFDoubleVectorFunction);
	}
}
