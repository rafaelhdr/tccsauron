package br.com.r4j.robosim.model;

import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import JSci.maths.AbstractDoubleMatrix;
import JSci.maths.AbstractDoubleSquareMatrix;
import JSci.maths.AbstractDoubleVector;
import JSci.maths.DoubleMatrix;
import JSci.maths.DoubleSquareMatrix;
import JSci.maths.DoubleVector;
import br.com.r4j.commons.util.MatrixUtil;
import br.com.r4j.configurator.Configurable;
import br.com.r4j.configurator.PropertiesHolder;
import br.com.r4j.math.FunctionsR;
import br.com.r4j.robosim.BaseSonarSensor;
import br.com.r4j.robosim.MapDependent;
import br.com.r4j.robosim.Wall;
import br.com.r4j.robosim.WorldMap;
import br.com.r4j.robosim.estimator.DoubleVectorFunction;
import br.com.r4j.robosim.estimator.EKFDoubleVectorFunction;
import br.com.r4j.robosim.estimator.PosteriorProbabilityDensityFunction;
import br.com.r4j.robosim.estimator.Sensor;
import br.com.r4j.robosim.estimator.SensorModel;
import br.com.r4j.robosim.estimator.UKFDoubleVectorFunction;


/**
 * 
 * @author giord
 *
 * Condições para produzir resultado:
 * 
 * 1 - O sonar certo ter produzido uma leitura.
 * 2 - Movimento pode ser considerado retilíneo.
 * 3 - Estar rastreando com sucesso uma parede.
 * 
 * 
 * Condições para determinar se uma parede esta sendo rastrada.
 * 1 - O sonar certo ter produzido uma leitura.
 * 2 - Movimento pode ser considerado retilíneo.
 * 
 * 
 * Operação
 * 
 * 1 - Determinar se uma parede está sendo observada ou não.
 * 2 - Verifica se uma parede está sendo rastreada.
 * 3 - Se não, procura uma para rastrear.
 * 4 - Se sim, verifica se a mesma está sendo rastreada ainda.
 * 5 - Se for a mesma, marca como sucesso, e zera contador de falhas.
 * 6 - Se não, marca como insucesso e incrementa contador de falhas.
 * 7 - Se contadorde falhas etiver zerado e mais de uma associação com sucesso tiver sido feita, então libera observação.
 * 8 - Se contador de falhas estiver em 3, então resseta tudo, limpando o buffer de parede associada.
 * 
 * @modelguid {51CF939A-1053-4F39-8A5F-F37BEDE065CE}
 */
//, InvertibleEKFDoubleVectorFunction
public class SonarModel implements SensorModel, Configurable, MapDependent, DoubleVectorFunction, UKFDoubleVectorFunction, EKFDoubleVectorFunction, PosteriorProbabilityDensityFunction
// PredictedEstimateConsumer, 
{
	/** @modelguid {842ABDB9-3F30-4094-9AE5-F43E85F3EEC5} */
	private static Log log = LogFactory.getLog(SonarModel.class.getName());
	/** @modelguid {C2CEDE5C-3894-4203-B6C7-5D27A28CFCA1} */
	private static Log logModel = LogFactory.getLog("sonarmodel");

	/** @modelguid {718041DA-4328-4DCE-BA5C-3F0B52B0AF6E} */
	private WorldMap map = null;
	
	/** @modelguid {6807DBC3-3D5C-4651-8439-751D0765050D} */
	private double phoErrorFront4mm = 0.05;
	/** @modelguid {B0E114A8-9AA3-4F0B-8BD0-38DDB6F5AC60} */
	private int idxSonar = 0;
	
	/** @modelguid {EEA03D4A-0537-4006-B1BE-C642B9F914A7} */
	private BaseSonarSensor sns = null;

	/** @modelguid {4B78AE5D-4D76-46E7-B0CF-E462D2046778} */
	private int currentIdx = 0;
	/** @modelguid {7D8E658C-7255-4DAA-8485-A33A055AB523} */
	private int previousIdx = 0;
	/** @modelguid {09F07A47-4576-4202-8644-AD7200B52C2D} */
	private double [] arrayReadings = null; 
	/** @modelguid {E7DE7187-06AE-46E3-AA35-43593CF7355A} */
	private double [][] arrayPoses = null; 
	/** @modelguid {9BCCF32F-BF81-4F97-972F-8749F583C6A2} */
	private double [] arraySigma2Theta = null; 
	/** @modelguid {B7267E76-FE88-4620-BA85-7F4A3E9EEEC1} */
	private boolean [] arrayValid = null; 

	/** @modelguid {8047B629-2DEE-4564-AF2D-B5EE8718920D} */
	private double wallRejectionValue = 1.645;
	/** @modelguid {DF6D655E-0C5A-492C-B874-59FB01BC58D3} */
	private double wallRejectionValue2 = wallRejectionValue*wallRejectionValue;

	/** @modelguid {0F7E1EEF-52C4-41D1-9D60-2C13B119BEEA} */
	private double rotRejectionValue = 1.645;
	/** @modelguid {51D83D8C-815D-43F1-B664-CF27E1F5C033} */
	private double rotRejectionValue2 = wallRejectionValue*wallRejectionValue;
	

	/** @modelguid {BCDB8369-5F5F-44C7-A940-F479D1A04A00} */
	private Wall [] arrayAssociatedWalls = null;
	/** @modelguid {CC04DDBD-5CF0-4B9B-8617-BAD1D793D4DB} */
	private int [] arrayMissCounter = null;
	
	/** @modelguid {BFDAA965-C6B0-4EDE-8849-AED0F0FEFF24} */
	private AbstractDoubleSquareMatrix obsCovariance = null; 

	/** @modelguid {134658D9-512C-450A-B583-922F392F1B6A} */
	private int uniqueId = 0;
	/** @modelguid {5190095F-4FCD-478C-955E-D33C8E939D64} */
	private static int uniqueIdCount = 0;


	/** @modelguid {C89D3325-4EF8-4F2A-B80F-B941AC00DE86} */
	private static int DIMENSION = 1;
	
	
	/** @modelguid {2FDE74A6-4DF5-47BB-95D7-EF12721E058C} */
	public SonarModel()
	{
		uniqueId = uniqueIdCount++;
		if (log.isDebugEnabled())
			log.debug("SonarModel: " + uniqueId);

		arrayReadings = new double[3];
		arraySigma2Theta = new double[3];
		arrayPoses = new double[3][3];
		arrayValid = new boolean[3];

		arrayAssociatedWalls = new Wall[1];
		arrayMissCounter = new int[1];

		currentIdx = 0;
		previousIdx = arrayReadings.length;
	}
	

	public void configure(PropertiesHolder props, String strBaseKey)
	{
		if (props.containsProperty(strBaseKey + "/idx_sonar"))
			idxSonar = props.getIntegerProperty(strBaseKey + "/idx_sonar").intValue();
		if (props.containsProperty(strBaseKey + "/phoErrorFront4mm"))
			phoErrorFront4mm = props.getDoubleProperty(strBaseKey + "/phoErrorFront4mm").doubleValue();

		if (log.isDebugEnabled())
			log.debug("idxSonar: " + idxSonar + ", phoErrorFront4mm: " + phoErrorFront4mm);
	}


	public void setSensor(Sensor sns)
	{
		this.sns = (BaseSonarSensor) sns;
	}


	public int getSonarIndex()
	{
		return idxSonar;
	}


	public String getName()
	{
		return "Sonar " + idxSonar + " Model ";
	}

	
	public void setWorldMap(WorldMap map)
	{
		this.map = map;
	}


	/** 
	 * Método invocado quando os dados estiverem disponíveis.
	 *
	 */
	public void dataAvailable()
	{
	}


/*
	public void predictedEstimateAvailable(AbstractDoubleVector mean, AbstractDoubleSquareMatrix covar)
	{
		int currentIdxTmp = (currentIdx + 1)%arrayReadings.length;
		arrayPoses[currentIdxTmp][0] = mean.getComponent(0); 
		arrayPoses[currentIdxTmp][1] = mean.getComponent(1); 
		arrayPoses[currentIdxTmp][2] = mean.getComponent(2);
	}
//
	 */


	public int getDataDimension()
	{
		return DIMENSION;
	}


//	////////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////////
//	/// Interface DoubleVectorFunction

	/**
	 * 2 - Verifica se uma parede está sendo rastreada.
	 * 3 - Se não, procura uma para rastrear.
	 * 4 - Se sim, verifica se a mesma está sendo rastreada ainda.
	 * 5 - Se for a mesma, marca como sucesso, e zera contador de falhas.
	 * 6 - Se não, marca como insucesso e incrementa contador de falhas.
	 * 7 - Se contador de falhas etiver zerado e mais de uma associação com sucesso tiver sido feita, então libera observação.
	 * 8 - Se contador de falhas estiver em 3, então resseta tudo, limpando o buffer de parede associada.
	 * @modelguid {D986BAF0-CA5B-4E00-84BF-27B76ED255E6}
	 */
	private AbstractDoubleMatrix H = new DoubleMatrix(DIMENSION, 3);
//	private AbstractDoubleMatrix Hcovar = new DoubleMatrix(2, 3);
//	private AbstractDoubleMatrix error4covar = new DoubleMatrix(3, 3);

	public boolean canProduceObservations(AbstractDoubleVector vectReadings, AbstractDoubleSquareMatrix sensorCovariance, AbstractDoubleVector stateEstimate, AbstractDoubleSquareMatrix stateCovarEstimate)
	{
		if (!this.prepareForNewObservation(vectReadings, sensorCovariance, stateEstimate, stateCovarEstimate))
			return false;
		if (!this.validateDate())
			return false;

		this.processProduceResults(stateEstimate, stateCovarEstimate.getElement(0, 0), stateCovarEstimate.getElement(1, 1), stateCovarEstimate.getElement(2, 2), 0);
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":arrayMissCounter[0]:" + arrayMissCounter[0]);
		if (arrayMissCounter[0] == 0)
		{
			this.calculateTransitionMatrixJacobian(stateEstimate);
			return true;
		}
		else 
			return false;
/*
		for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++)
			error4covar.setElement(i, j, 2*stateCovar.getElement(i, j));
//*/
	}

	public AbstractDoubleVector produceResults(AbstractDoubleVector state, AbstractDoubleVector snsReadings, AbstractDoubleSquareMatrix stateCovar)
	{
		AbstractDoubleVector obsPredicted = new DoubleVector(getDataDimension());
		double [] arrayValues = new double[DIMENSION];
		this.predictObservation(state.getComponent(0), state.getComponent(1), state.getComponent(2), arrayAssociatedWalls[0], arrayValues);
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":arrayValues:(" + arrayValues[0] + ")");
		obsPredicted.setComponent(0, arrayValues[0]);
//		obsPredicted.setComponent(1, arrayValues[1]);
//		obsPredicted.setComponent(2, arrayValues[2]);

		return obsPredicted;
	}


	/** @modelguid {ADD102C2-DA97-4268-B300-5DD81B64B179} */
	public AbstractDoubleSquareMatrix getObservationCovariance(AbstractDoubleSquareMatrix sensorCovariance)
	{
		AbstractDoubleSquareMatrix covar = new DoubleSquareMatrix(DIMENSION);
		covar.setElement(0, 0, obsCovariance.getElement(0, 0));
/*
		error4covar.setElement(2, 2, 2*obsCovariance.getElement(0, 0));
		AbstractDoubleMatrix covarRes = Hcovar.multiply(error4covar).multiply((AbstractDoubleMatrix) Hcovar.transpose());
		covar.setElement(1, 1, covarRes.getElement(0, 0));
		covar.setElement(1, 2, covarRes.getElement(0, 1));
		covar.setElement(2, 1, covarRes.getElement(1, 0));
		covar.setElement(2, 2, covarRes.getElement(1, 1));
//*/
		return covar;
	}


	/** @modelguid {44104A48-636D-4ABB-B94B-9A2BF0469FB4} */
	public AbstractDoubleVector getObservation(AbstractDoubleVector sensorReadings)
	{
		double reading = sensorReadings.getComponent(idxSonar);
		AbstractDoubleVector obs = new DoubleVector(1);
		obs.setComponent(0, reading);
		return obs;
	}

//	////////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////////
//	/// Interface EKFDoubleVectorFunction

	/** @modelguid {28AE9DE4-1910-4127-B96F-7DC6E7330243} */
	public AbstractDoubleMatrix getTransitionMatrixJacobian(AbstractDoubleVector state)
	{
		return H;
	}


	/** @modelguid {2B861E4A-E6B7-48AC-B567-4E533D011A19} */
	private void calculateTransitionMatrixJacobian(AbstractDoubleVector state)
	{
		Wall wall = arrayAssociatedWalls[0];
		if (wall != null)
		{
			if (FunctionsR.angularDist(state.getComponent(2) + sns.getThetaS(idxSonar), wall.getTheta()) > Math.PI/2)
			{
				H.setElement(0, 0, +wall.getCosTheta());
				H.setElement(0, 1, +wall.getSinTheta());

				double thetaMix = (state.getComponent(2) - wall.getTheta());
				double cosMix = Math.cos(thetaMix), sinMix = Math.sin(thetaMix);
				H.setElement(0, 2, -1*(sns.getXS(idxSonar)*sinMix + sns.getYS(idxSonar)*cosMix));
			}
			else
			{
				H.setElement(0, 0, -wall.getCosTheta());
				H.setElement(0, 1, -wall.getSinTheta());

				double thetaMix = state.getComponent(2) - wall.getTheta();
				double cosMix = Math.cos(thetaMix), sinMix = Math.sin(thetaMix);
				H.setElement(0, 2, sns.getXS(idxSonar)*sinMix + sns.getYS(idxSonar)*cosMix);
			}
		}
		else
		{
			H.setElement(0, 0, 1);
			H.setElement(0, 1, 1);
			H.setElement(0, 2, 1);
		}
/*
		double dX23 = arrayPoses[currentIdx][0] - arrayPoses[previousIdx][0];
		double dY23 = arrayPoses[currentIdx][1] - arrayPoses[previousIdx][1];
		double d23 = Math.sqrt(dX23*dX23 + dY23*dY23);
		double r23 = arrayReadings[currentIdx] - arrayReadings[previousIdx];
		double salpha = r23/d23;
		double calpha = Math.sqrt(1 - salpha*salpha);
		double d23_3 = d23*d23*d23;

		if (d23 != 0)
		{
			H.setElement(1, 0, dX23*r23/(d23_3));
			H.setElement(1, 1, dY23*r23/(d23_3));
			H.setElement(2, 0, dX23*r23/(d23_3*d23*calpha));
			H.setElement(2, 1, dY23*r23/(d23_3*d23*calpha));

			Hcovar.setElement(0, 0, H.getElement(1, 0));
			Hcovar.setElement(0, 1, H.getElement(1, 1));
			Hcovar.setElement(1, 0, H.getElement(2, 0));
			Hcovar.setElement(1, 1, H.getElement(2, 1));

		}
		else
		{
			H.setElement(1, 0, 0); H.setElement(1, 1, 0);
			H.setElement(2, 0, 0); H.setElement(2, 1, 0);

			Hcovar.setElement(0, 0, 0); Hcovar.setElement(0, 1, 0);
			Hcovar.setElement(1, 0, 0); Hcovar.setElement(1, 1, 0);
		}
		H.setElement(1, 2, 0);
		H.setElement(2, 2, 0);

		Hcovar.setElement(0, 2, 1/d23);
		Hcovar.setElement(1, 2, -r23/(d23*calpha));
//*/	
	}

//	////////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////////
//	/// Interface UKFDoubleVectorFunction

	/** @modelguid {8CEF8869-2034-4AF0-A2D7-733DD53CDDEA} */
	public AbstractDoubleMatrix produceResults(AbstractDoubleMatrix sigmaIn, AbstractDoubleVector state, AbstractDoubleVector sensorReadings, AbstractDoubleMatrix sigmaError, AbstractDoubleSquareMatrix stateCovar)
	{
		AbstractDoubleMatrix sigmaOut = new DoubleMatrix(sigmaIn.rows(), sigmaIn.columns()); 
		double [] arrayValues = new double[DIMENSION];
		for (int idxInput = 0; idxInput < sigmaIn.columns(); idxInput++)
		{
			this.predictObservation(sigmaIn.getElement(0, idxInput), 
										sigmaIn.getElement(1, idxInput), 
										sigmaIn.getElement(2, idxInput), 
										 arrayAssociatedWalls[0], arrayValues);
			if (logModel.isDebugEnabled())
				logModel.debug(uniqueId + ":predicted[" + idxInput + "]:" + arrayValues[0] + ", sigmaError.getElement(0, idxInput): " + sigmaError.getElement(0, idxInput));
			sigmaOut.setElement(0, idxInput, arrayValues[0] + sigmaError.getElement(0, idxInput));
/*
			logModel.debug(uniqueId + ":ukf_arrayValues:(" + arrayValues[0] + ":" + arrayValues[1] + ":" + arrayValues[2] + ")");
			obsPredictedSigma.setElement(0, idxInput, arrayValues[0] + sigmaError.getElement(0, idxInput));
			obsPredictedSigma.setElement(0, idxInput, arrayValues[1] + sigmaError.getElement(1, idxInput));
			obsPredictedSigma.setElement(0, idxInput, arrayValues[2] + sigmaError.getElement(2, idxInput));
//*/
		}
		return sigmaOut;
	}


//	////////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////////
//	/// Interface PosteriorProbabilityDensityFunction

	/** @modelguid {B69C7791-4BE8-4125-9B04-01A0A8DD0CD4} */
	private AbstractDoubleSquareMatrix covarInv = null;
	/** @modelguid {33C5FE3C-F33E-4E14-A5AF-22EF9ECD6D8F} */
	private double readingPF = 0;
	/** @modelguid {E0625629-E603-4BF6-AD92-6628973FDD76} */
	private double pdfConst = 0;

	/** @modelguid {83C820A2-F616-4199-BAA2-25490E07203E} */
	public boolean canProduceObservationsPF(AbstractDoubleVector vectReadings, AbstractDoubleSquareMatrix sensorCovariance, AbstractDoubleVector stateEstimate, AbstractDoubleSquareMatrix stateCovarEstimate)
	{
		this.prepareForNewObservation(vectReadings, sensorCovariance, stateEstimate, stateCovarEstimate);
		boolean bCanProduceObs = this.validateDate();
		if (bCanProduceObs)
		{
/*
			this.calculateTransitionMatrixJacobian(stateEstimate);
			for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++)
				error4covar.setElement(i, j, 2*stateCovar.getElement(i, j));
//*/
		}
		return bCanProduceObs;
	}


	/** @modelguid {C32EF915-FBC9-4E40-8601-FB7639B035A0} */
	public void setAdditiveNoise(AbstractDoubleSquareMatrix obsCovarianceTmp)
	{
		this.obsCovariance = new DoubleSquareMatrix(DIMENSION);
		obsCovariance.setElement(0, 0, obsCovarianceTmp.getElement(0, 0));
//		error4covar.setElement(2, 2, 2*obsCovarianceTmp.getElement(0, 0));
/*
		AbstractDoubleMatrix covarRes = Hcovar.multiply(error4covar).multiply((AbstractDoubleMatrix) Hcovar.transpose());
		obsCovariance.setElement(1, 1, covarRes.getElement(0, 0));
		obsCovariance.setElement(1, 2, covarRes.getElement(0, 1));
		obsCovariance.setElement(2, 1, covarRes.getElement(1, 0));
		obsCovariance.setElement(2, 2, covarRes.getElement(1, 1));
//*/
		covarInv = obsCovariance.inverse();
		pdfConst = 1.0/Math.sqrt(((AbstractDoubleSquareMatrix) obsCovariance.scalarMultiply(2*Math.PI)).det());
		if (logModel.isDebugEnabled())
		{
			logModel.debug(uniqueId + ":obsCovariance: \r\n" + MatrixUtil.toString(obsCovariance, 9, 4));
			logModel.debug(uniqueId + ":covarInv: \r\n" + MatrixUtil.toString(covarInv, 9, 4));
			logModel.debug(uniqueId + ":pdfConst: " + pdfConst);
		}
		if (pdfConst < 1)
			pdfConst = 1;
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":pdfConst(2): " + pdfConst);
	}


	/** @modelguid {73596DBA-C5EA-455B-A66F-A6777A189EA8} */
	public void copyParticleData(int idxFrom, int idxTo)
	{
		if (arrayAssociatedWalls.length <= idxFrom)
			this.changeArrayWallSize(idxFrom + 1);

		if (arrayAssociatedWalls.length <= idxTo)
			this.changeArrayWallSize(idxTo + 1);

		arrayAssociatedWalls[idxTo] = arrayAssociatedWalls[idxFrom];
		arrayMissCounter[idxFrom] = arrayMissCounter[idxFrom];
	}


	/** @modelguid {97C8B3D4-20BB-4D0E-B26F-A540E2D62A90} */
	public void setObservations(AbstractDoubleVector readings)
	{
		this.readingPF = readings.getComponent(0);
	}

	
	/** @modelguid {5F94B152-9353-4B86-AB76-B4467BB889BF} */
	public double stateProbability(AbstractDoubleMatrix inputStates, int rowObjectCount)
	{
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":stateProbability:" +  rowObjectCount);
		if (arrayAssociatedWalls.length >= rowObjectCount)
			this.changeArrayWallSize(rowObjectCount + 1);

		AbstractDoubleVector state = MatrixUtil.getRow(inputStates, rowObjectCount);


		if (arrayAssociatedWalls[rowObjectCount] == null || 
			!this.checkWall(state.getComponent(0), state.getComponent(1), state.getComponent(2), 
							arrayReadings[currentIdx], arrayAssociatedWalls[rowObjectCount], 360, obsCovariance.getElement(0, 0)))
		{
			arrayAssociatedWalls[rowObjectCount] = this.findWall(
								state.getComponent(0), state.getComponent(1), state.getComponent(2), arrayReadings[currentIdx]);
		}
		
		if (arrayAssociatedWalls[rowObjectCount] != null)
		{
			double [] arrayValues = new double[3];
			this.predictObservation(state.getComponent(0), state.getComponent(1), state.getComponent(2), 
											arrayAssociatedWalls[rowObjectCount], arrayValues);
			double diff = arrayValues[0] - readingPF;
			double expoent = diff*covarInv.getElement(0, 0)*diff;
			logModel.warn(uniqueId + ":diff: " + diff + ", expoent: " + expoent + ", pdfConst: " + pdfConst);
			logModel.warn(uniqueId + ":pdfConst*Math.exp(-1.0/2.0*expoent): " + pdfConst*Math.exp(-1.0/2.0*expoent));
			return pdfConst*Math.exp(-1.0/2.0*expoent);
		}
		else
		{
			logModel.warn(uniqueId + ":stateProbability: retornando 0 (zero !!)!!");
			return 0;
		}
	}	


//	////////////////////////////////////////////////////////////////////////////////
//	/// Método internos
	
	/** @modelguid {84FF2A73-C3C7-445D-8614-01237E3381CF} */
	private void changeArrayWallSize(int sizeNew)
	{
		Wall [] arrayAssociatedWallsTmp = new Wall[sizeNew];
		int [] arrayMissCounterTmp = new int[sizeNew];
		for (int i = 0; i < sizeNew && i < arrayAssociatedWalls.length; i++)
		{
			arrayAssociatedWallsTmp[i] = arrayAssociatedWalls[i];
			arrayMissCounterTmp[i] = arrayMissCounter[i];
		}
		for (int i = arrayAssociatedWalls.length; i < sizeNew; i++)
			arrayMissCounterTmp[i] = 0;

		arrayAssociatedWalls = arrayAssociatedWallsTmp;
		arrayMissCounter = arrayMissCounterTmp;
	}


	/**
	 *  1- Faz update quando uma nova observação vai ser tratada.
	 * @modelguid {39C5C6BF-918B-4069-A4B6-25F222BD2B41}
	 */
	protected boolean prepareForNewObservation(AbstractDoubleVector vectReadings, AbstractDoubleSquareMatrix sensorCovariance, AbstractDoubleVector statePredicted, AbstractDoubleSquareMatrix stateCovar)
	{
		if (vectReadings.getComponent(idxSonar) == -1)
			return false;

		previousIdx = currentIdx;
		currentIdx = (currentIdx + 1)%arrayReadings.length;

		arrayReadings[currentIdx] = vectReadings.getComponent(idxSonar);

		arrayPoses[currentIdx][0] = statePredicted.getComponent(0); 
		arrayPoses[currentIdx][1] = statePredicted.getComponent(1); 
		arrayPoses[currentIdx][2] = statePredicted.getComponent(2);
		arraySigma2Theta[currentIdx] = stateCovar.getElement(2, 2);

		if (obsCovariance == null)
			obsCovariance = new DoubleSquareMatrix(1);
		obsCovariance.setElement(0, 0, sensorCovariance.getElement(idxSonar, idxSonar));
		
		return true;
	}


	/**
	 * 2 - Verifica se com a última medição é possível gerar algum resultado.
	 * @modelguid {7098362F-4836-4B5B-ADF1-EE87455C16EF}
	 */
	protected boolean validateDate()
	{
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":testing arrayReadings[currentIdx]: " + arrayReadings[currentIdx] + ", arrayReadings[currentIdx] != -1: " + (arrayReadings[currentIdx] != -1) + ", idxSonar = " + idxSonar);

		double dThetaPrevious = arrayPoses[previousIdx][2];
		double dThetaCurrent = arrayPoses[currentIdx][2];
		double dSigma2ThetaPrevious = arraySigma2Theta[previousIdx];
		double dSigma2ThetaCurrent = arraySigma2Theta[currentIdx];

		// Testa para ver se o robo não rodou.
		double sigma2Rot = dSigma2ThetaPrevious + dSigma2ThetaCurrent;
		double rotDist = FunctionsR.angularDist(dThetaPrevious, dThetaCurrent);
		if (rotDist*rotDist > sigma2Rot*rotRejectionValue2)
		{
			if (logModel.isDebugEnabled())
			{
				logModel.debug("rotDist: " + rotDist + ", sigma2Rot: " + sigma2Rot + ", rotRejectionValue2: " + rotRejectionValue2 + ", dSigma2ThetaCurrent: " + dSigma2ThetaCurrent);
				logModel.debug("não valido");
			}
			arrayValid[currentIdx] = false;
			for (int i = 0; i < arrayAssociatedWalls.length; i++)
			{
				arrayAssociatedWalls[i] = null;
				arrayMissCounter[i] = 0;
			}
			return false;
		}

		// Verifica se a leitura é de alguma coisa
		if (sns.isOutOfRange(arrayReadings[currentIdx]))
		{
			arrayValid[currentIdx] = false;
			for (int i = 0; i < arrayAssociatedWalls.length; i++)
				arrayMissCounter[i]++;
			return false;
		}
		arrayValid[currentIdx] = true;
		
		// Verifica se tem um número mínimo de leituras válidas
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":");
		boolean bCanProduceResults = true;
		if (logModel.isDebugEnabled())
		{
			for (int i = 0; i < arrayReadings.length; i++)
			{
				bCanProduceResults = bCanProduceResults & arrayValid[i];
				logModel.debug("\t" + arrayValid[i]);
			}
		}
		else
			for (int i = 0; i < arrayReadings.length; i++)
				bCanProduceResults = bCanProduceResults & arrayValid[i];


		// Se tem um número mínimo de leituras, verifica se elas podem corresponder a 
		// uma parede.
		if (bCanProduceResults)
		{
			bCanProduceResults = this.testForWall();
			if (logModel.isDebugEnabled())
				logModel.debug(uniqueId + ":this.testForWall(): " + bCanProduceResults);

			// Se não pôde associar uma parede as leituras, armazena a informação
			// de que mais uma vez uma parede não pôde ser identificada nas leituras.
			if (!bCanProduceResults)
				for (int i = 0; i < arrayAssociatedWalls.length; i++)
					arrayMissCounter[i]++;
		}

		return bCanProduceResults;
	}


	/**
	 * 2.1 - Verifica se as leituras correspondem a uma parede.
	 * @modelguid {B92A49F8-5465-4549-843E-D609DAE080BC}
	 */
	private boolean testForWall()
	{
		int idx1 = (arrayReadings.length + currentIdx - 2)%arrayReadings.length;
		int idx2 = (arrayReadings.length + currentIdx - 1)%arrayReadings.length;
		int idx3 = (arrayReadings.length + currentIdx - 0)%arrayReadings.length;

		double dX12 = arrayPoses[idx2][0] - arrayPoses[idx1][0];
		double dY12 = arrayPoses[idx2][1] - arrayPoses[idx1][1];
		double d12 = Math.sqrt(dX12*dX12 + dY12*dY12);

		double dX23 = arrayPoses[idx3][0] - arrayPoses[idx2][0];
		double dY23 = arrayPoses[idx3][1] - arrayPoses[idx2][1];
		double d23 = Math.sqrt(dX23*dX23 + dY23*dY23);
		
		double r12 = arrayReadings[idx1] - arrayReadings[idx2]; 
		double r23 = arrayReadings[idx2] - arrayReadings[idx3];

		if (logModel.isDebugEnabled())
		{
			logModel.debug(uniqueId + ":arrayReadings[idx1] = " + arrayReadings[idx1] + ", arrayReadings[idx2] = " + arrayReadings[idx2] + ", arrayReadings[idx3] = " + arrayReadings[idx3]);
			logModel.debug(uniqueId + ":d12 = " + d12 + ", d23 = " + d23);
			logModel.debug(uniqueId + ":r12 = " + r12 + ", r23 = " + r23);
		}
		
		double sinAlpha = (r12 + r23)/(d12 + d23);
		if (Math.abs(sinAlpha) > 1 && Math.abs(sinAlpha) < 1.15)
		{
			if (logModel.isDebugEnabled())
				logModel.debug(uniqueId + ":acoxambrando:sinAlpha = " + sinAlpha);
			sinAlpha = FunctionsR.sign(sinAlpha)*1;
		}
		if (Math.abs(sinAlpha) > 1)
		{
			if (logModel.isDebugEnabled())
				logModel.debug(uniqueId + ":sinAlpha = " + sinAlpha);
			return false;
		}
		double alpha = Math.asin(sinAlpha);
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":alpha = " + alpha);
	
		double d12Sigma = d12*phoErrorFront4mm; 
		double d23Sigma = d23*phoErrorFront4mm; 
		double r12Sigma = 2*sns.getReadingSigma() + d12Sigma*sinAlpha; 
		double r23Sigma = 2*sns.getReadingSigma() + d23Sigma*sinAlpha; 

		double d12Sigma2 = d12Sigma*d12Sigma; 
		double d23Sigma2 = d23Sigma*d23Sigma; 
		double r12Sigma2 = r12Sigma*r12Sigma; 
		double r23Sigma2 = r23Sigma*r23Sigma; 
		double rSigma2 = sns.getReadingSigma()*sns.getReadingSigma(); 
		
		AbstractDoubleSquareMatrix eqCovar = new DoubleSquareMatrix(4);
		AbstractDoubleVector fDeriv = new DoubleVector(4);
		
		eqCovar.setElement(0, 0, d12Sigma2); eqCovar.setElement(0, 1, d12Sigma2*sinAlpha);  eqCovar.setElement(0, 2, 0); eqCovar.setElement(0, 3, 0);
		eqCovar.setElement(1, 0, d12Sigma2*sinAlpha); eqCovar.setElement(1, 1, r12Sigma2);  eqCovar.setElement(1, 2, 0); eqCovar.setElement(1, 3, rSigma2);
		eqCovar.setElement(2, 0, 0); eqCovar.setElement(2, 1, 0);  eqCovar.setElement(2, 2, d23Sigma2); eqCovar.setElement(2, 3, d23Sigma2*sinAlpha);
		eqCovar.setElement(3, 0, 0); eqCovar.setElement(3, 1, rSigma2);  eqCovar.setElement(3, 2, d23Sigma2*sinAlpha); eqCovar.setElement(3, 3, r23Sigma2);
		
		fDeriv.setComponent(0, -r12/d12/d12);
		fDeriv.setComponent(1, 1/d12);
		fDeriv.setComponent(2, r23/d23/d23);
		fDeriv.setComponent(3, -1/d23);
		
		double fVar = eqCovar.multiply(fDeriv).scalarProduct(fDeriv);
		double fValue = r12/d12 - r23/d23;
		
		double modZ2 = Math.abs(fValue*fValue/fVar);
		
		if (logModel.isDebugEnabled())
		{
			logModel.debug("eqCovar: \r\n" + MatrixUtil.toString(eqCovar, 9, 4));
			logModel.debug("fDeriv: \r\n" + MatrixUtil.toString(fDeriv, 9, 4));
			logModel.debug(uniqueId + ":modZ2: " + modZ2 + ", fValue: " + fValue + ", fVar: " + fVar + ", wallRejectionValue2: " + wallRejectionValue2);
		}
		if (modZ2 < wallRejectionValue2) // (<teste de hiptese>)
			return true;
		else
			return false;
	}


	/**
	 *
	 * 1 - Prucura todas a paredes com inclinação dentro da zona de busca de inclinações.
	 * 2 - Seleciona as paredes que possuem distância a x dentro da faixa de erro.
	 * 3 - seleciona a parede com centor de massa mais próximo do sonar.
	 *
	 * @param double xR
	 * @param double yR
	 * @param double thetaR
	 * @param double reading
	 * @return
	 * @modelguid {5649A7BD-4E0B-44FD-9EE7-921B45ED17CA}
	 */
	private Wall findWall(double xR, double yR, double thetaR, double reading, double sigmaPosition2, double sigmaReading2, double sigmaTheta2)
	{
		double cosThetaR = Math.cos(thetaR), sinThetaR = Math.sin(thetaR);
		double beta = sns.getBeta(), thetaMin = 0, thetaMax = 0;
		double sigmaTheta = Math.sqrt(2*sigmaTheta2);
		thetaMin = thetaR + sns.getThetaS(idxSonar) - beta/2 - sigmaTheta;
		thetaMax = thetaR + sns.getThetaS(idxSonar) + beta/2 + sigmaTheta;

		double xSA = xR + sns.getXS(idxSonar)*cosThetaR - sns.getYS(idxSonar)*sinThetaR;
		double ySA = yR + sns.getYS(idxSonar)*cosThetaR + sns.getXS(idxSonar)*sinThetaR;
		if (logModel.isDebugEnabled())
		{
			logModel.debug(uniqueId + ":findWall:(xSA,ySA):(" + xSA + "," + ySA + ")");
			logModel.debug(uniqueId + ":findWall:sigmaReading2:" + sigmaReading2 + ", sigmaPosition2:" + sigmaPosition2);
		}
		List listWalls = map.findWalls(thetaMin, thetaMax, xSA, ySA, reading, sigmaPosition2, sigmaReading2);
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":findWall:listWalls:" + listWalls);

		Wall wallMin = null;
		double d2Min = 1000000000;
		Iterator itWalls = listWalls.iterator();
		while (itWalls.hasNext())
		{
			Wall wall = (Wall) itWalls.next();
			double testValue = ((Double) itWalls.next()).doubleValue();
			if (testValue < d2Min)
			{
				wallMin = wall;
				d2Min = testValue;
			}
		}
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":findWall:wallMin:" + wallMin);

		return wallMin;
	}
	/** @modelguid {15373662-B2D9-46B0-92A7-313254C521DF} */
	private Wall findWall(double xR, double yR, double thetaR, double reading)
	{
		double cosThetaR = Math.cos(thetaR), sinThetaR = Math.sin(thetaR);
		double beta = sns.getBeta(), thetaMin = 0, thetaMax = 0;
		thetaMin = thetaR + sns.getThetaS(idxSonar) - beta/2 - Math.PI/2;
		thetaMax = thetaR + sns.getThetaS(idxSonar) + beta/2 + Math.PI/2;

		double xSA = xR + sns.getXS(idxSonar)*cosThetaR - sns.getYS(idxSonar)*sinThetaR;
		double ySA = yR + sns.getYS(idxSonar)*cosThetaR + sns.getXS(idxSonar)*sinThetaR;
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":findWall:(xSA,ySA):(" + xSA + "," + ySA + ")");

		List listWalls = map.findWalls(thetaMin, thetaMax, xSA, ySA, reading);
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":findWall:listWalls:" + listWalls);

		Wall wallMin = null;
		double d2Min = 1000000000;
		Iterator itWalls = listWalls.iterator();
		while (itWalls.hasNext())
		{
			Wall wall = (Wall) itWalls.next();
			double testValue = ((Double) itWalls.next()).doubleValue();
			if (testValue < d2Min)
			{
				wallMin = wall;
				d2Min = testValue;
			}
		}
		if (logModel.isDebugEnabled())
			logModel.debug(uniqueId + ":findWall:wallMin:" + wallMin);

		return wallMin;
	}


	/**
	 *
	 * 1 - Prucura todas a paredes com inclinação dentro da zona de busca de inclinações.
	 * 2 - Seleciona as paredes que possuem distância a x dentro da faixa de erro.
	 * 3 - seleciona a parede com centor de massa mais próximo do sonar.
	 *
	 * @param double xR
	 * @param double yR
	 * @param double thetaR
	 * @param double reading
	 * @param Wall wallAssociated
	 * @return
	 * @modelguid {D75B259C-82AE-4275-9922-FB7B853F8C37}
	 */
	private boolean checkWall(double xR, double yR, double thetaR, double reading, Wall wallAssociated, double sigmaPosition2, double sigmaReading2)
	{
		double cosThetaR = Math.cos(thetaR);
		double sinThetaR = Math.sin(thetaR);

		double xSA = xR + sns.getXS(idxSonar)*cosThetaR - sns.getYS(idxSonar)*sinThetaR;
		double ySA = yR + sns.getYS(idxSonar)*cosThetaR + sns.getXS(idxSonar)*sinThetaR;

		return map.validateWallReading(xSA, ySA, sns.getThetaS(idxSonar), thetaR, reading, wallAssociated, sigmaPosition2, sigmaReading2);
	}


	/**
	 *
	 * 1 - Prucura todas a paredes com inclinação dentro da zona de busca de inclinações.
	 * 2 - Seleciona as paredes que possuem distância a x dentro da faixa de erro.
	 * 3 - seleciona a parede com centor de massa mais próximo do sonar.
	 *
	 * @param double xR
	 * @param double yR
	 * @param double thetaR
	 * @param double reading
	 * @param Wall wall
	 * @return
	 * @modelguid {E8B09038-8318-4CE6-8926-3C023C581208}
	 */
	private void predictObservation(double xR, double yR, double thetaR, Wall wall, double [] arrayValues)
	{
		double cosThetaR = Math.cos(thetaR);
		double sinThetaR = Math.sin(thetaR);

		double xSA = xR + sns.getXS(idxSonar)*cosThetaR - sns.getYS(idxSonar)*sinThetaR;
		double ySA = yR + sns.getYS(idxSonar)*cosThetaR + sns.getXS(idxSonar)*sinThetaR;

		double xSW = xSA*wall.getCosTheta() + ySA*wall.getSinTheta();

		if (logModel.isDebugEnabled())
		{
			logModel.debug(uniqueId + ":predictObservation:wall: " + wall);
			logModel.debug(uniqueId + ":predictObservation:xSW: " + xSW + ", thetaR: " + thetaR);
			logModel.debug(uniqueId + ":predictObservation:thetaR: " + thetaR + ", wall.getTheta(): " + wall.getTheta());
			logModel.debug(uniqueId + ":predictObservation:FunctionsR.angularDist(thetaR + sns.getThetaS(idxSonar), wall.getTheta()): " + FunctionsR.angularDist(thetaR + sns.getThetaS(idxSonar), wall.getTheta()) + ", Math.PI/2: " + (Math.PI/2));
		}

		if (FunctionsR.angularDist(thetaR + sns.getThetaS(idxSonar), wall.getTheta()) > Math.PI/2)
			arrayValues[0] = (xSW - wall.getD());
		else
			arrayValues[0] = (wall.getD() - xSW);
/*
		double dX23 = arrayPoses[currentIdx][0] - arrayPoses[previousIdx][0];
		double dY23 = arrayPoses[currentIdx][1] - arrayPoses[previousIdx][1];
		double d23 = Math.sqrt(dX23*dX23 + dY23*dY23);
		double r23 = arrayReadings[currentIdx] - arrayReadings[previousIdx];

		double salpha = r23/d23;
		double calpha = Math.sqrt(1 - salpha*salpha);
		arrayValues[1] = salpha;
		arrayValues[2] = calpha;
//*/
	}


	/** @modelguid {DE4FCB56-DDE0-4CFB-A954-D19C9E3A92ED} */
	private void processProduceResults(AbstractDoubleVector state, double sigmaX2, double sigmaY2, double sigmaTheta2, int idxParticle)
	{
		if (logModel.isDebugEnabled())
		{
			logModel.debug(uniqueId + ":" + idxSonar + ":produceResults:state = " + MatrixUtil.toString(state, 7, 3));
			logModel.debug(uniqueId + ":            :arrayReadings[currentIdx] = " + arrayReadings[currentIdx]);
		}
		double sigmaPosition2 = sigmaX2 + sigmaY2, sigmaReading2 = obsCovariance.getElement(0, 0);

		// Verifica se uma parede já assciada continua sendo observada.
		if (arrayAssociatedWalls[idxParticle] != null && arrayMissCounter[idxParticle] <= 2)
		{
			if (logModel.isDebugEnabled())
				logModel.debug(uniqueId + ":if (arrayAssociatedWalls[idxParticle] != null && arrayMissCounter[idxParticle] <= 2):arrayAssociatedWalls[idxParticle] = " + arrayAssociatedWalls[idxParticle]);
			boolean bSameWall = this.checkWall(state.getComponent(0), state.getComponent(1), state.getComponent(2), arrayReadings[currentIdx], arrayAssociatedWalls[idxParticle], sigmaPosition2, sigmaReading2);
			if (logModel.isDebugEnabled())
				logModel.debug(uniqueId + ":bSameWall:" + bSameWall);
			if (bSameWall)
				arrayMissCounter[idxParticle] = 0;
			else
				arrayMissCounter[idxParticle]++;
		}

		// Procura associar uma parede caso nenhuma está associada ou se a antiga associada
		// já caducou.
		if (arrayAssociatedWalls[idxParticle] == null || arrayMissCounter[idxParticle] > 2)
		{
			if (logModel.isDebugEnabled())
				logModel.debug(uniqueId + ":if (arrayAssociatedWalls[idxParticle] == null || arrayMissCounter[idxParticle] > 2)");
			Wall wall = this.findWall(state.getComponent(0), state.getComponent(1), state.getComponent(2), arrayReadings[currentIdx], sigmaPosition2, sigmaReading2, sigmaTheta2);

			if (wall != null)
			{
				if (logModel.isDebugEnabled())
					logModel.debug(uniqueId + ":if (wall != null) else");
				arrayAssociatedWalls[idxParticle] = wall;
				arrayMissCounter[idxParticle] = 0;
			}
			else
			{
				if (arrayMissCounter[idxParticle] > 2)
					arrayAssociatedWalls[idxParticle] = null;

				arrayMissCounter[idxParticle]++;
			}
		}
		if (logModel.isDebugEnabled())
		{
			logModel.debug(uniqueId + ":arrayMissCounter[idxParticle]:" + arrayMissCounter[idxParticle]);
			logModel.debug(uniqueId + ":arrayAssociatedWalls[idxParticle] = " + arrayAssociatedWalls[idxParticle]);
			logModel.debug(uniqueId + ":state = " + MatrixUtil.toString(state, 7, 3));
		}
	}
}

