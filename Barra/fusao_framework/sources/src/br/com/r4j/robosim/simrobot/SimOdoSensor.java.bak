package br.com.r4j.robosim.simrobot;

import java.util.Date;
import java.util.Random;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import JSci.maths.AbstractDoubleSquareMatrix;
import JSci.maths.AbstractDoubleVector;
import JSci.maths.DoubleSquareMatrix;
import br.com.r4j.commons.util.MatrixUtil;
import br.com.r4j.configurator.Configurable;
import br.com.r4j.configurator.PropertiesHolder;
import br.com.r4j.math.JSciMatrixMath;
import br.com.r4j.robosim.Pose2D;
import br.com.r4j.robosim.*;
import br.com.r4j.robosim.estimator.Sensor;


public class SimOdoSensor implements Sensor, Configurable, RealPoseDependent, MapDependent
{
	private static Log log = LogFactory.getLog(SimOdoSensor.class.getName());
	private static Log logSens = LogFactory.getLog("odom");

	private Pose2D lastReading = null;
	private Pose2D reading = null;
	private double xError = 0;
	private double yError = 0;
	private double thetaError = 0;
	private double thetaTranslError = 0;

	private double d = -1;
	private double dThetaTransl = -1;

	private double phoErrorFront4mm = 0.05;
	private double phoErrorSide4mm = 0.02;

	private double thetaErrorFix = 2.0*Math.PI/180;
	private double thetaError4rad = 0.05;

	private WorldMap map = null;
	private Random rnd = null;


	public SimOdoSensor()
	{
		rnd = new Random((new Date()).getTime());
		reading = new Pose2D(0, 0, 0);
	}


	public String getName()
	{
		return "Odometer Sensor";
	}


	public void setWorldMap(WorldMap map)
	{
		this.map = map;
		AbstractDoubleVector loc = map.getInitialLocalization();
		reading = new Pose2D(loc.getComponent(0), loc.getComponent(1), loc.getComponent(2));
	}


	public void configure(PropertiesHolder props, String strBaseKey)
	{
		if (props.containsProperty(strBaseKey + "/phoErrorFront4mm"))
			phoErrorFront4mm = props.getDoubleProperty(strBaseKey + "/phoErrorFront4mm").doubleValue();
		if (props.containsProperty(strBaseKey + "/phoErrorSide4mm"))
			phoErrorSide4mm = props.getDoubleProperty(strBaseKey + "/phoErrorSide4mm").doubleValue();
		if (props.containsProperty(strBaseKey + "/thetaErrorFixGra"))
			thetaErrorFix = props.getDoubleProperty(strBaseKey + "/thetaErrorFixGra").doubleValue()*Math.PI/180;
		if (props.containsProperty(strBaseKey + "/thetaError4Gra"))
			thetaError4rad = props.getDoubleProperty(strBaseKey + "/thetaError4Gra").doubleValue()*Math.PI/180;
	}


	public void setRealPose(Pose2D realPose)
	{
//		log.debug("setRealPose: realPose = " + realPose);
		this.lastReading = this.reading;
		this.reading = realPose;
	}


	/** 
	 * Método invocado quando os dados estiverem disponíveis.
	 */
	public void dataAvailable()
	{
		float dX = (float) (reading.getX() - lastReading.getX());
		float dY = (float) (reading.getY() - lastReading.getY());
		d = Math.sqrt(dX*dX + dY*dY);

		double thetaTransl = 0;
		if (dX*dX > 0.025)
		{
			if (dX > 0)
				thetaTransl = Math.atan(dY/dX);
			else
				thetaTransl = Math.atan(dY/dX) + Math.PI;
		}
		else
		{
			if (dY > 0)
				thetaTransl = Math.PI/2;
			else
				thetaTransl = 3*Math.PI/2;
		}

		dThetaTransl = thetaTransl - lastReading.getTheta();


		double phoErrorFront = d*phoErrorFront4mm;
		double phoErrorSide = d*phoErrorSide4mm;
		
		thetaError = thetaError4rad*(reading.getTheta() - lastReading.getTheta());
		thetaError = Math.sqrt(thetaError*thetaError + thetaErrorFix*thetaErrorFix);

		thetaTransError = thetaError4rad*dThetaTransl;
		thetaTransError = Math.sqrt(thetaTransError*thetaTransError + thetaErrorFix*thetaErrorFix);

		log.debug("thetaError4rad: " + thetaError4rad + ", (reading.getTheta() - lastReading.getTheta()) = " + (reading.getTheta() - lastReading.getTheta()));

		log.debug("phoErrorFront: " + phoErrorFront);
		log.debug("phoErrorSide: " + phoErrorSide);
		log.debug("thetaError: " + thetaError);

		phoErrorFront = rnd.nextGaussian()*phoErrorFront;
		phoErrorSide = rnd.nextGaussian()*phoErrorSide;
		thetaError = rnd.nextGaussian()*thetaError;
		thetaTransError = rnd.nextGaussian()*thetaTransError;

		double sen = Math.sen(), cos = 0;
		if (Math.abs(d) > 0.05)
		{
			sen = dY/d; 
			cos = dX/d;
		}

		this.xError = -sen*phoErrorSide + cos*phoErrorFront;
		this.yError = cos*phoErrorSide + sen*phoErrorFront;

//		log.debug("dataAvailable: (" + this.xError + ", " + this.yError + ", " + this.thetaError + ")");
		logSens.debug("dataAvailable: (" + this.xError + ", " + this.yError + ", " + this.thetaError + ")");
	}


	public int getDataDimension()
	{
		return 3;
	}


	public void getData(AbstractDoubleVector output)
	{
//		log.debug("getData");
		output.setComponent(0, reading.getX() - lastReading.getX() + xError);
		output.setComponent(1, reading.getY() - lastReading.getY() + yError);
		output.setComponent(2, (reading.getTheta() - lastReading.getTheta()) + thetaError);
		logSens.debug(MatrixUtil.toString(output, 9, 2));
	}


	public boolean hasNewData()
	{
		return lastReading != null;
	}



	public AbstractDoubleSquareMatrix getDataCovariance()
	{
		float dX = (float) (reading.getX() - lastReading.getX());
		float dY = (float) (reading.getY() - lastReading.getY());
		double d = Math.sqrt(dX*dX + dY*dY);

		double phoErrorFront = d*d*phoErrorFront4mm*phoErrorFront4mm;
		double phoErrorSide = d*d*phoErrorSide4mm*phoErrorSide4mm;
		double thetaError = thetaError4rad*(reading.getTheta() - lastReading.getTheta());
		thetaError = thetaError*thetaError + thetaErrorFix*thetaErrorFix;

		AbstractDoubleSquareMatrix covarDist = new DoubleSquareMatrix(2);
		covarDist.setElement(0, 0, phoErrorFront);
		covarDist.setElement(1, 1, phoErrorSide);
		AbstractDoubleSquareMatrix rotateMat = new DoubleSquareMatrix(2);
		AbstractDoubleSquareMatrix rotateMatT = new DoubleSquareMatrix(2);
		
		if (Math.abs(d) > 0.005)
			JSciMatrixMath.rotate2D(rotateMat, rotateMatT, dY/d, dX/d);

		covarDist = rotateMat.multiply(covarDist).multiply(rotateMatT);

		AbstractDoubleSquareMatrix covar = new DoubleSquareMatrix(3);
		JSciMatrixMath.setInto(covar, covarDist, 0, 0);
		covar.setElement(2, 2, Math.abs(thetaError));

		logSens.debug("\r\n" + MatrixUtil.toString(covar, 9, 4));
		return covar;
	}
}


