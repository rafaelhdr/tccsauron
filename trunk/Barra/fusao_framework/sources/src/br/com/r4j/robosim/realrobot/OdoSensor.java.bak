package br.com.r4j.robosim.realrobot;

import java.util.*;
import java.util.List;
import java.io.*;
import java.awt.event.*;
import java.awt.image.*;
import java.awt.*;
import java.net.URL;

import br.com.r4j.commons.util.*;
import br.com.r4j.gui.*;

import br.com.r4j.robosim.*;
import br.com.r4j.robosim.estimator.*;
import br.com.r4j.configurator.*;
import br.com.r4j.math.*;
import JSci.maths.*;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


public class OdoSensor implements Sensor, Configurable
{
	private Pose2D lastReading = null;
	private Pose2D reading = null;

	private double phoErrorFront4mm = 0.05;
	private double phoErrorSide4mm = 0.02;

	private double thetaErrorFix = 2.0*Math.PI/180;
	private double thetaError4rad = 0.05;


	public String getName()
	{
		return "Odometer Sensor";
	}


	public void configure(PropertiesHolder props, String strBaseKey)
	{
		if (props.containsProperty(strBaseKey + "phoErrorFront4mm"))
			phoErrorFront4mm = props.getDoubleProperty(strBaseKey + "phoErrorFront4mm").doubleValue();
		if (props.containsProperty(strBaseKey + "phoErrorSide4mm"))
			phoErrorSide4mm = props.getDoubleProperty(strBaseKey + "phoErrorSide4mm").doubleValue();
		if (props.containsProperty(strBaseKey + "thetaErrorFix"))
			thetaErrorFix = props.getDoubleProperty(strBaseKey + "thetaErrorFix").doubleValue();
		if (props.containsProperty(strBaseKey + "thetaError4rad"))
			thetaError4rad = props.getDoubleProperty(strBaseKey + "thetaError4rad").doubleValue();
	}


	public void setReadings(Pose2D reading)
	{
		this.lastReading = this.reading;
		this.reading = reading;
	}


	/** 
	 * Método invocado quando os dados estiverem disponíveis.
	 *
	 */
	public void dataAvailable()
	{
		// não precisa fazer nada ...
	}


	public int getDataDimension()
	{
		return 3;
	}


	public void getData(AbstractDoubleVector output)
	{
		output.setComponent(0, reading.getX() - lastReading.getX());
		output.setComponent(1, reading.getY() - lastReading.getY());
		output.setComponent(2, Math.PI*(reading.getTheta() - lastReading.getTheta())/180);
	}


	public boolean hasNewData()
	{
		return lastReading != null;
	}



	public AbstractDoubleSquareMatrix getDataCovariance()
	{
		float dX = (float) (reading.getX() - lastReading.getX());
		float dY = (float) (reading.getY() - lastReading.getY());
		double d = Math.sqrt(dX*dX + dY*dY);

		double phoErrorFront = d*d*phoErrorFront4mm*phoErrorFront4mm;
		double phoErrorSide = d*d*phoErrorSide4mm*phoErrorSide4mm;
		double thetaError = thetaError4rad*thetaError4rad*Math.PI*(reading.getTheta() - lastReading.getTheta())/180;
		thetaError = thetaError*thetaError + thetaErrorFix*thetaErrorFix;

		AbstractDoubleSquareMatrix covarDist = new DoubleSquareMatrix(2);
		covarDist.setElement(0, 0, phoErrorFront);
		covarDist.setElement(1, 1, phoErrorSide);
		AbstractDoubleSquareMatrix rotateMat = new DoubleSquareMatrix(2);
		AbstractDoubleSquareMatrix rotateMatT = new DoubleSquareMatrix(2);
		JSciMatrixMath.rotate2D(rotateMat, rotateMatT, dY/d, dX/d);
		covarDist = rotateMat.multiply(covarDist).multiply(rotateMatT);

		AbstractDoubleSquareMatrix covar = new DoubleSquareMatrix(3);
		JSciMatrixMath.setInto(covar, covarDist, 0, 0);
		covar.setElement(2, 2, Math.abs(thetaError));

		return covar;
	}
}


