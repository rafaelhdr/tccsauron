package br.com.r4j.robosim.model;

import JSci.maths.AbstractDoubleMatrix;
import JSci.maths.AbstractDoubleSquareMatrix;
import JSci.maths.AbstractDoubleVector;
import br.com.r4j.robosim.MapDependent;
import br.com.r4j.robosim.WorldMap;
import br.com.r4j.robosim.estimator.DoubleVectorFunction;
import br.com.r4j.robosim.estimator.EKFDoubleVectorFunction;
import br.com.r4j.robosim.estimator.EstimateConsumer;
import br.com.r4j.robosim.estimator.InvertibleEKFDoubleVectorFunction;
import br.com.r4j.robosim.estimator.PosteriorProbabilityDensityFunction;
import br.com.r4j.robosim.estimator.Sensor;
import br.com.r4j.robosim.estimator.SensorModel;
import br.com.r4j.robosim.estimator.UKFDoubleVectorFunction;


public class SonarModel implements SensorModel, MapDependent, EstimateConsumer, DoubleVectorFunction, UKFDoubleVectorFunction, EKFDoubleVectorFunction, InvertibleEKFDoubleVectorFunction//, AditiveNoiseFunction //,  ParticleCloudPredictorFunction
{
	public void setSensor(Sensor sns)
	{
	}


	public String getName()
	{
		return "Sonar Model";
	}

	
	/** 
	 * Método invocado quando os dados estiverem disponíveis.
	 *
	 */
	public void dataAvailable()
	{
		// não precisa fazer nada ...
	}


	public int getDataDimension()
	{
		return -1;
	}


	public void setWorldMap(WorldMap map)
	{
	}


	public void estimateAvailable(AbstractDoubleVector mean, AbstractDoubleSquareMatrix covar)
	{
	}


	/**
	 * retorna true se é possível obter algum dado das leituras sensoriais.
	 */
	public boolean produceResults(AbstractDoubleVector state, AbstractDoubleVector obsPredicted, AbstractDoubleSquareMatrix stateCovar)
	{
		return false;
	}


	public AbstractDoubleSquareMatrix getObservationCovariance(AbstractDoubleSquareMatrix sensorCovariance)
	{
		return null;
	}


	public AbstractDoubleVector getObservation(AbstractDoubleVector sensorReadings)
	{
		return null;
	}


	public AbstractDoubleMatrix getTransitionMatrixJacobian(AbstractDoubleVector state)
	{
		return null;
	}


	public void calculate(AbstractDoubleMatrix input, AbstractDoubleMatrix output)
	{
	}


	public void setPreviousInformation(AbstractDoubleVector input)
	{
	}


	public double calculate(AbstractDoubleVector input)
	{
		return -1;
	}


	public double calculate(AbstractDoubleMatrix input, int rowObjectCount)
	{
		return -1;
	}


	/* (non-Javadoc)
	 * @see br.com.r4j.robosim.estimator.InvertibleEKFDoubleVectorFunction#produceInverseResults(JSci.maths.AbstractDoubleVector, JSci.maths.AbstractDoubleVector)
	 */
	public AbstractDoubleVector produceInverseResults(AbstractDoubleVector stateEstimatei_minus1, AbstractDoubleVector vectReadings)
	{
		// TODO Auto-generated method stub
		return null;
	}


	/* (non-Javadoc)
	 * @see br.com.r4j.robosim.estimator.InvertibleEKFDoubleVectorFunction#getInverseTransitionMatrixJacobian(JSci.maths.AbstractDoubleVector)
	 */
	public AbstractDoubleMatrix getInverseTransitionMatrixJacobian(AbstractDoubleVector readings)
	{
		// TODO Auto-generated method stub
		return null;
	}


	/* (non-Javadoc)
	 * @see br.com.r4j.robosim.estimator.UKFDoubleVectorFunction#produceResults(JSci.maths.AbstractDoubleMatrix, JSci.maths.AbstractDoubleVector, JSci.maths.AbstractDoubleMatrix)
	 */
	public boolean produceResults(AbstractDoubleMatrix sigmaIn, AbstractDoubleVector readings, AbstractDoubleMatrix sigmaOut)
	{
		// TODO Auto-generated method stub
		return false;
	}
}
